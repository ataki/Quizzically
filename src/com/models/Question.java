package com.models;

import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

public class Question {
	
	
	public enum Type{
		QuestionResponse {
			public String toString() {
				return "question-response";
			}
		},
		FillInTheBlank {
			public String toString() {
				return "fill-in-the-blank";
			}
		},
		MultiAnswer {
			public String toString(){
				return "multi-answer";
			}
		},
		PictureResponse{
			public String toString(){
				return "picture-response";
			}
		},
		MultiChoice{
			public String toString(){
				return "multi-choice";
			}
		},
		MultiChoiceMultiAnswer{
			public String toString(){
				return "multi-choice-multi-answer";
			}
		},
		Matching{
			public String toString(){
				return "matching";
			}
		},
		AutoGenerated {
			public String toString(){
				return "auto-generated";
			}
		},
		Graded {
			public String toString(){
				return "graded";
			}
		}
		

	}
	

	
	
	
	public List<String> texts;
	public List<String> answers;
	public String url;
	public Date time;
	public Type type;
	
	public Question(List<String>texts, List<String>answers, String url,
							String type) 
	{
		this.texts = texts;
		this.answers = answers;
		this.url = url;
		for(Type item: Type.values()){
			if(type.equals(item.toString()))
				this.type = item;
		}
	}
	
	/*
	 * depending on the question type, Answer's
	 * index can mean either:
	 * - the index of hte question with which to associate
	 * - 
	 */
	/*
	public class Answer {
		String url;
		String text;
		int index;
		public Answer(String url, String text, int index) {
			this.index =index;
			this.url = url;
			this.text = text;
		}
		
		@Override
		public boolean equals(Object other) {
		    // Not strictly necessary, but often a good optimization
		    if (this == other)
		      return true;
		    if (!(other instanceof Answer))
		      return false;
		    Answer otherA = (Answer) other;
		    return 
		      (url.equals(otherA.url) &&
		    	text.equals(otherA.text) &&
		    	index == otherA.index);
		}
		@Override
		public int hashCode() { 
		   int hash = 1;
		   hash = hash * 31 + text.hashCode();
		   return hash;
		}
	}
	*/
	
	/**
	 * check our answer with given input; does so 
	 * by sorting answers by index and then checking
	 * for equality among all answers.
	 * Raises question of how we are going to represent
	 * answers on the front-end
	 * 
	 * @param answers
	 * @return
	 */
	/*
	public boolean checkAnswer(List<Answer>answers) {
		// sort the answer by a certain heuristic 
		Collections.sort(answers, new Comparator<Answer>() {
			@Override
			public int compare(Answer arg0, Answer arg1) {
				if(arg0.index == arg1.index) return 0;
				if(arg0.index < arg1.index) return -1;
				return 1;
			}
		});
		if(answers.size() != Ans.size()) return false;
		for(int i =0; i < answers.size(); i++) {
			if(!answers.get(i).equals(Ans.get(i))) {
				return false;
			}
		}
		
		return true;
	}
	
	*/
}
